#pragma config(StandardModel, "RVW Buggybot")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//*dave platten 09-27-2017

int speedvalue = 60;
int turnSpeed = 20;
short facing = 0;  //direction robot is facing
short gyro1 = 0;
short openPath = 35;
short stopNow = 25;
short stopCloser = 15;
const int sonmax = 4;
short sondir[sonmax][2];
short northdir = 0;
short southdir = 0;
short eastdir = 0;
short westdir = 0;
short northdist = 0;
short southdist = 0;
short eastdist = 0;
short westdist = 0;
short godir = 0;
const int mapmax = 500;
short map[mapmax][6];  //facing, north, east, south, west
int mapidx = -1;
short fwdcnt = 0;



void goForward()
{
	forward(0.049, seconds, speedvalue);
	fwdcnt ++;
}

void getCloser()
{
	while (SensorValue(sonar) > stopCloser)
	{
		goForward();
	}
}

void tweak(short gd, short twa, short spd)
{
	float turnd = twa / 5;
	if (turnd < 5)
	{
		turnd = 5;
	}
	gyro1 = SensorValue(gyro);
	while ((gyro1 < gd - twa) | (gyro1 > gd + twa))
	{
		gyro1 = SensorValue(gyro);
		if (gyro1 < gd - twa)
		{
			turnRight(turnd, degrees, spd);
		}
		else if (gyro1 > gd + twa)
		{
			turnLeft(turnd, degrees, spd);
		}
	}
}


void faceDirection(short gd)
{
	//gd = gyro direction
	tweak(gd, 2500, turnSpeed);
	tweak(gd, 1700, turnSpeed);
	tweak(gd, 800, turnSpeed);
	tweak(gd, 400, turnSpeed);
  tweak(gd, 200, turnSpeed);
	tweak(gd, 100, turnSpeed);
	tweak(gd, 50, turnSpeed);
	tweak(gd, 25, turnSpeed);
	tweak(gd, 2, 15);
}

short getFacingDir(short f1)
{
	short result = 0;

	if ((f1 >= 450) & (f1 < 1350))  //east
  {
   	result = 900;
  }
  else if ((f1 >= 1350) & (f1 < 2250))  //south
  {
   	result = 1800;
	}
	else if ((f1 >= 2250) & (f1 < 3150))  //west
	{
   	result = 2700;
	}
	else  //north
	{
   	result = 0;
	}
	return result;
}

void writeMap()
{
	mapidx ++;
	map[mapidx][0] = getFacingDir(facing);
	map[mapidx][1] = fwdcnt;
	map[mapidx][2] = northdist;
	map[mapidx][3] = eastdist;
	map[mapidx][4] = southdist;
	map[mapidx][5] = westdist;
}


void analyze()
{
	short adir = 0;
	short adist = 0;

	northdir = 0;
	southdir = 0;
	eastdir = 0;
	westdir = 0;

	northdist = 0;
	southdist = 0;
	eastdist = 0;
	westdist = 0;

	for (int i1 = 0; i1 < sonmax; i1++)
  {
  	adir = sondir[i1][1];
  	adist = sondir[i1][0];
    if ((adir >= 450) & (adir < 1350))  //east
    {
    	if (adist > eastdist)
    	{
    		eastdist = adist;
    		eastdir = adir;
    	}
    }
    else if ((adir >= 1350) & (adir < 2250))  //south
    {
    	if (adist > southdist)
    	{
    		southdist = adist;
    		southdir = adir;
    	}
    }
    else if (adir >= 2250 & adir < 3150)  //west
    {
    	if (adist > westdist)
    	{
    		westdist = adist;
    		westdir = adir;
    	}
    }
    else  //north
    {
    	if (adist > northdist)
    	{
    		northdist = adist;
    		northdir = adir;
    	}
    }
  }
  writeMap();
}

void superLook()
{
	faceDirection(0);
	sondir[0][0] = SensorValue(sonar);
  sondir[0][1] = SensorValue(gyro);
	for (int i1 = 1; i1 < sonmax; i1++)
  {
  	turnRight(159, degrees, turnSpeed);
  	waitUntilMotorStop(motorA);
  	waitUntilMotorStop(motorB);
    sondir[i1][0] = SensorValue(sonar);
    sondir[i1][1] = SensorValue(gyro);
  }
  //faceDirection(facing);
}


bool Repeating()
{
	bool answer = true;
	if (mapidx > 9)  //don't check too early
	{
		for (int i1 = 0; i1 < 4; i1++)
		{
			if (map[mapidx - i1][0] != map[mapidx - (4+i1)][0])  //dir
			{
				answer = false;
				break;
			}
			if (abs(map[mapidx - i1][1] - map[mapidx - (4+i1)][1]) > 5 )  //distance
			{
				answer = false;
				break;
			}
			if (abs(map[mapidx - i1][1] - map[mapidx - (4+i1)][1]) > 5 )  //north
			{
				answer = false;
				break;
			}
			if (abs(map[mapidx - i1][1] - map[mapidx - (4+i1)][1]) > 5 )  //east
			{
				answer = false;
				break;
			}
			if (abs(map[mapidx - i1][1] - map[mapidx - (4+i1)][1]) > 5 )  //south
			{
				answer = false;
				break;
			}
			if (abs(map[mapidx - i1][1] - map[mapidx - (4+i1)][1]) > 5 )  //west
			{
				answer = false;
				break;
			}
		}
	}
	else
	{
		answer = false;
	}
	return answer;
}



short decide()
{
	short ddir;
	short nodir = -900;
	bool rep = Repeating();
	if (rep != false)
	{
		nodir = map[mapidx - 3][0]; //dir of next turn
	}

	switch (getFacingDir(facing))
	{
		case 0:
		{
			if ((eastdist > openPath) & (eastdir != nodir))
			{
				ddir = eastdir;
			}
			else if ((northdist > openPath) & (northdir != nodir))
			{
				ddir = northdir;
			}
			else if ((westdist > openPath) & (westdir != nodir))
			{
				ddir = westdir;
			}
			else
			{
				ddir = 9999;
			}
			break;
		}
		case 900:
		{
			if ((southdist > openPath) & (southdir != nodir))
			{
				ddir = southdir;
			}

			else if ((eastdist > openPath) & (eastdir != nodir))
			{
				ddir = eastdir;
			}
			else if ((northdist > openPath) & (northdir != nodir))
			{
				ddir = northdir;
			}
			else
			{
				ddir = 9999;
			}
			break;
		}
		case 1800:
		{
			if ((westdist > openPath) & (westdir != nodir))
			{
				ddir = westdir;
			}

			else if ((southdist > openPath) & (southdir != nodir))
			{
				ddir = southdir;
			}

			else if ((eastdist > openPath) & (eastdir != nodir))
			{
				ddir = eastdir;
			}
			else
			{
				ddir = 9999;
			}

			break;
		}
		case 2700:
		{
			if ((northdist > openPath) & (northdir != nodir))
			{
				ddir = northdir;
			}

			else if ((westdist > openPath) & (westdir != nodir))
			{
				ddir = westdir;
			}

			else if ((southdist > openPath) & (southdir != nodir))
			{
				ddir = southdir;
			}

			else
			{
				ddir = 9999;
			}
		}
	}
	return ddir;
}

void proceed()
{
	facing = SensorValue(gyro);
	fwdcnt = 0;

	while ((SensorValue(sonar) > stopNow) & (SensorValue(light) >= 65))
	{
		goForward();
	}
	if (SensorValue(light) < 65)
	{
		forward(1.25, rotations, speedvalue);
	}
}

void lookAround()
{
		superLook();
}

void whichWay()
{
	lookAround();
	analyze();
	godir = decide();
	if (godir == 9999)
	{
		faceDirection(facing);
		getCloser();
		lookAround();
		analyze();
		godir = decide();
		if (godir == 9999)
		{
			if (facing < 1800)
			{
				godir = facing + 1800;
			}
			else
			{
				godir = facing - 1800;
			}
		}
	}
	faceDirection(godir);
}

task main()
{
	wait1Msec(50);
	while (true)
	{
		whichWay();
		proceed();
	}
}
